// Code generated by protoc-gen-go.
// source: proto/server.proto
// DO NOT EDIT!

/*
Package server is a generated protocol buffer package.

It is generated from these files:
	proto/server.proto

It has these top-level messages:
	Fragment
	Metadata
	Chunk
	Result
*/
package server

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Fragment is our union of the types can we can pass to PutStream.
type Fragment struct {
	// Types that are valid to be assigned to Msg:
	//	*Fragment_Metadata
	//	*Fragment_Chunk
	Msg isFragment_Msg `protobuf_oneof:"msg"`
}

func (m *Fragment) Reset()                    { *m = Fragment{} }
func (m *Fragment) String() string            { return proto.CompactTextString(m) }
func (*Fragment) ProtoMessage()               {}
func (*Fragment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type isFragment_Msg interface {
	isFragment_Msg()
}

type Fragment_Metadata struct {
	Metadata *Metadata `protobuf:"bytes,1,opt,name=metadata,oneof"`
}
type Fragment_Chunk struct {
	Chunk *Chunk `protobuf:"bytes,2,opt,name=chunk,oneof"`
}

func (*Fragment_Metadata) isFragment_Msg() {}
func (*Fragment_Chunk) isFragment_Msg()    {}

func (m *Fragment) GetMsg() isFragment_Msg {
	if m != nil {
		return m.Msg
	}
	return nil
}

func (m *Fragment) GetMetadata() *Metadata {
	if x, ok := m.GetMsg().(*Fragment_Metadata); ok {
		return x.Metadata
	}
	return nil
}

func (m *Fragment) GetChunk() *Chunk {
	if x, ok := m.GetMsg().(*Fragment_Chunk); ok {
		return x.Chunk
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Fragment) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Fragment_OneofMarshaler, _Fragment_OneofUnmarshaler, _Fragment_OneofSizer, []interface{}{
		(*Fragment_Metadata)(nil),
		(*Fragment_Chunk)(nil),
	}
}

func _Fragment_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Fragment)
	// msg
	switch x := m.Msg.(type) {
	case *Fragment_Metadata:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Metadata); err != nil {
			return err
		}
	case *Fragment_Chunk:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Chunk); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Fragment.Msg has unexpected type %T", x)
	}
	return nil
}

func _Fragment_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Fragment)
	switch tag {
	case 1: // msg.metadata
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Metadata)
		err := b.DecodeMessage(msg)
		m.Msg = &Fragment_Metadata{msg}
		return true, err
	case 2: // msg.chunk
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Chunk)
		err := b.DecodeMessage(msg)
		m.Msg = &Fragment_Chunk{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Fragment_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Fragment)
	// msg
	switch x := m.Msg.(type) {
	case *Fragment_Metadata:
		s := proto.Size(x.Metadata)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Fragment_Chunk:
		s := proto.Size(x.Chunk)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Metadata is our stream's "header". Our server expects exactly one Metadata
// message at the beginning of a PutStream request.
type Metadata struct {
	// name is the name of our stream.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// length is the expected total number of bytes.
	Length int64 `protobuf:"varint,2,opt,name=length" json:"length,omitempty"`
}

func (m *Metadata) Reset()                    { *m = Metadata{} }
func (m *Metadata) String() string            { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()               {}
func (*Metadata) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Metadata) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Metadata) GetLength() int64 {
	if m != nil {
		return m.Length
	}
	return 0
}

// Chunk is our message envelope for a raw chunk of bytes. Our server expects
// a series of these after the Metadata header.
type Chunk struct {
	// data is our raw data
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *Chunk) Reset()                    { *m = Chunk{} }
func (m *Chunk) String() string            { return proto.CompactTextString(m) }
func (*Chunk) ProtoMessage()               {}
func (*Chunk) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Chunk) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// Result is the result of a PutStream call.
type Result struct {
	Msg string `protobuf:"bytes,1,opt,name=msg" json:"msg,omitempty"`
}

func (m *Result) Reset()                    { *m = Result{} }
func (m *Result) String() string            { return proto.CompactTextString(m) }
func (*Result) ProtoMessage()               {}
func (*Result) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Result) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func init() {
	proto.RegisterType((*Fragment)(nil), "server.Fragment")
	proto.RegisterType((*Metadata)(nil), "server.Metadata")
	proto.RegisterType((*Chunk)(nil), "server.Chunk")
	proto.RegisterType((*Result)(nil), "server.Result")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for MyService service

type MyServiceClient interface {
	// PutStream lets the client send a stream of bytes over gRPC.
	PutStream(ctx context.Context, opts ...grpc.CallOption) (MyService_PutStreamClient, error)
}

type myServiceClient struct {
	cc *grpc.ClientConn
}

func NewMyServiceClient(cc *grpc.ClientConn) MyServiceClient {
	return &myServiceClient{cc}
}

func (c *myServiceClient) PutStream(ctx context.Context, opts ...grpc.CallOption) (MyService_PutStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_MyService_serviceDesc.Streams[0], c.cc, "/server.MyService/PutStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &myServicePutStreamClient{stream}
	return x, nil
}

type MyService_PutStreamClient interface {
	Send(*Fragment) error
	CloseAndRecv() (*Result, error)
	grpc.ClientStream
}

type myServicePutStreamClient struct {
	grpc.ClientStream
}

func (x *myServicePutStreamClient) Send(m *Fragment) error {
	return x.ClientStream.SendMsg(m)
}

func (x *myServicePutStreamClient) CloseAndRecv() (*Result, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for MyService service

type MyServiceServer interface {
	// PutStream lets the client send a stream of bytes over gRPC.
	PutStream(MyService_PutStreamServer) error
}

func RegisterMyServiceServer(s *grpc.Server, srv MyServiceServer) {
	s.RegisterService(&_MyService_serviceDesc, srv)
}

func _MyService_PutStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MyServiceServer).PutStream(&myServicePutStreamServer{stream})
}

type MyService_PutStreamServer interface {
	SendAndClose(*Result) error
	Recv() (*Fragment, error)
	grpc.ServerStream
}

type myServicePutStreamServer struct {
	grpc.ServerStream
}

func (x *myServicePutStreamServer) SendAndClose(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func (x *myServicePutStreamServer) Recv() (*Fragment, error) {
	m := new(Fragment)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _MyService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "server.MyService",
	HandlerType: (*MyServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PutStream",
			Handler:       _MyService_PutStream_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "proto/server.proto",
}

func init() { proto.RegisterFile("proto/server.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 249 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x3c, 0x90, 0x4f, 0x4b, 0xc4, 0x30,
	0x10, 0xc5, 0xb7, 0xae, 0x2d, 0xed, 0xf8, 0x87, 0x65, 0x0e, 0xb2, 0x54, 0x0f, 0x12, 0x10, 0xf6,
	0xd4, 0xe2, 0x0a, 0x1e, 0x3d, 0x28, 0xc8, 0x5e, 0x16, 0x24, 0xfb, 0x09, 0xe2, 0x3a, 0xa4, 0xc5,
	0x26, 0x59, 0xd2, 0xe9, 0x82, 0xdf, 0x5e, 0x9a, 0xfe, 0xb9, 0xbd, 0xf7, 0xf2, 0xf2, 0x9b, 0x4c,
	0x00, 0x4f, 0xde, 0xb1, 0x2b, 0x5b, 0xf2, 0x67, 0xf2, 0x45, 0x30, 0x98, 0x0c, 0x2e, 0x7f, 0xd0,
	0xce, 0xe9, 0x86, 0x4a, 0x75, 0xaa, 0x4b, 0x65, 0xad, 0x63, 0xc5, 0xb5, 0xb3, 0xed, 0xd0, 0x12,
	0x15, 0xa4, 0x9f, 0x5e, 0x69, 0x43, 0x96, 0xb1, 0x80, 0xd4, 0x10, 0xab, 0x1f, 0xc5, 0x6a, 0x1d,
	0x3d, 0x46, 0x9b, 0xab, 0xed, 0xaa, 0x18, 0x91, 0xfb, 0x31, 0xdf, 0x2d, 0xe4, 0xdc, 0xc1, 0x27,
	0x88, 0x8f, 0x55, 0x67, 0x7f, 0xd7, 0x17, 0xa1, 0x7c, 0x33, 0x95, 0x3f, 0xfa, 0x70, 0xb7, 0x90,
	0xc3, 0xe9, 0x7b, 0x0c, 0x4b, 0xd3, 0x6a, 0xf1, 0x0a, 0xe9, 0x44, 0x41, 0x84, 0x4b, 0xab, 0x0c,
	0x85, 0x29, 0x99, 0x0c, 0x1a, 0xef, 0x20, 0x69, 0xc8, 0x6a, 0xae, 0x02, 0x6e, 0x29, 0x47, 0x27,
	0xee, 0x21, 0x0e, 0xc0, 0xfe, 0xd2, 0xfc, 0xb4, 0x6b, 0x19, 0xb4, 0xc8, 0x21, 0x91, 0xd4, 0x76,
	0x0d, 0xe3, 0x2a, 0x4c, 0x19, 0x89, 0xbd, 0xdc, 0xbe, 0x41, 0xb6, 0xff, 0x3b, 0x90, 0x3f, 0xd7,
	0x47, 0xc2, 0x67, 0xc8, 0xbe, 0x3a, 0x3e, 0xb0, 0x27, 0x65, 0x70, 0x5e, 0x6b, 0x5a, 0x3d, 0xbf,
	0x9d, 0x92, 0x81, 0x26, 0x16, 0x9b, 0xe8, 0x3b, 0x09, 0x3f, 0xf4, 0xf2, 0x1f, 0x00, 0x00, 0xff,
	0xff, 0x5e, 0x7d, 0x4d, 0xa6, 0x5d, 0x01, 0x00, 0x00,
}
